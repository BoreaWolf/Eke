% Riccardo Orizio
% 9 April 2016
% Network Security report of EKE
% Requested content:
%  - The protocol requirements, in terms of security, network (which transport
%    layer? why?), terminals, servers, credential databases, etc.
%  - The actual protocol rules, including one successful and at least one
%    unsuccessful run.
%  - An analysis of how the protocol satisfies the requirements set out by point
%    (1) above.


\documentclass[10pt, letterpaper]{article}

\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{textcomp}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color,soul}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{graphicx}
\graphicspath{ {../images/} }
\usepackage{float}

% Every list item will start with a dash instead of a dot
\def\labelitemi{-}

% Personal commands

% Title
\title{Protocollo di autenticazione EKE:\\ progetto di Network Security}
\author{Riccardo Orizio}
\date{9 Aprile 2016}

\begin{document}

\maketitle

\section{Abstract}
Nel documento verrà brevemente descritto il protocollo EKE, le sue
caratteristiche e limitazioni e come è stato implementato in questo progetto.

\section{Requisiti del protocollo}
L'idea dalla quale è nato il protocollo di autenticazione EKE è data dalla
mancanza di autenticazione, sia singola sia mutua, dell'algoritmo per la
creazione di una chiave di sessione effimera Diffie-Hellman.

Tale algoritmo consente a due entità di creare una chiave di sessione temporanea
da zero, senza la necessità di conoscere alcun tipo di informazione aggiuntiva
riguardante l'altro interlocutore.
L'algoritmo è semplice, basato sullo scambio di tre pacchetti nei quali vengono
scambiate le informazioni necessarie per la generazione della chiave da parte di
entrambi i client, ovvero:
\begin{itemize}
	\item \textbf{p}: un numero primo
	\item \textbf{g}: un generatore di $Z_p^*$
	\item \textbf{$T_{a/b}$}: parte della chiave effimera
\end{itemize}
Grazie al teorema di Eulero, entrambi i client sono in grado di derivare la
stessa chiave effimera seppur solamente parte della chiave viene scambiata.
Il problema legato a questo algoritmo è la mancanza di autenticazione che lo
rende soggetto al Man-in-the-middle attack: Trudy può semplicemente rigirare le
richieste ricevute da Alice a Bob ed utilizzare le sue risposte per creare una
chiave effimera con Alice senza problemi.
Per questo EKE introduce l'autenticazione, basandosi su una password conosciuta
da entrambi i client e una coppia di challenge, che permette di limitare questo
tipo di attacco e garantisce inoltre una mutua autenticazione.
La password condivisa dai client è importante per i primi messaggi, ma anche nel
caso in cui essa venisse recuperata, le uniche informazioni alla quali si
avrebbero accesso sarebbero dei valori numerici di poca utilità.

Per poter eseguire il protocollo è quindi necessario conoscere esclusivamente
una \textit{password} condivisa tra i client, o con un server\footnote{In questo
caso il server avrebbe tutte le password di tutti i client salvate in chiaro in
un database}, che vogliono autenticarsi e che tutti i client abbiano un nome
univoco all'interno della rete nella quale si stanno autenticando.

\section{Il protocollo}
Il protocollo si basa sullo scambio di quattro pacchetti totali nella quale
viene generata la chiave effimera ed entrambi i client si autenticano a vicenda.
La sequenza dei messaggi scambiati è la seguente, sapendo che entrambi conoscono
la password e di conseguenza conoscono il valore $w=f(pwd)$:
\begin{itemize}
	\item \textbf{Client\textrightarrow Server}: {[} ClientID, A, g, p {]}
		\begin{description}
			\item [ClientID:] Identificativo del client
			\item [A:] $E_w( g^{S_a} \mod p ) = E_w( T_a )$
			\item [g:] Generatore di $Z_p^*$
			\item [p:] Numero primo scelto casualmente dal client
		\end{description}
	\item \textbf{Server\textrightarrow Client}: {[} ServerID, B {]}
		\begin{description}
			\item [ServerID:] Identificativo del server (o secondo client)
			\item [B:] $E_w( g^{S_b} \mod p, c_1 ) = E_w( T_b, c_1 )$
		\end{description}
	\item \textbf{Client\textrightarrow Server} $[E_k( c_1, c_2 )]$
		\begin{description}
			\item [k:] chiave effimera $= T_b^{S_a} \mod p$
		\end{description}
	\item \textbf{Server\textrightarrow Client} $[E_k( c_2 )]$
		\begin{description}
			\item [k:] chiave effimera $= T_a^{S_b} \mod p$
		\end{description}
\end{itemize}
$S_a$ ed $S_b$ sono numeri casuali scelti nell'intervallo $[1,p)$,
rispettivamente calcolati dal client e dal server; $c_1$ e $c_2$ sono numeri
casuali usati come challenge per ottenere la mutua autenticazione tra i due
interlocutori.
Errori di comunicazione possono sorgere quando i due client hanno una diversa
password condivisa, di conseguenza non sono in grado di generare la stessa
chiave effimera e le challenge non verranno verificate a causa della sbagliata
decifrazione dei valori scambiati.

\section{Analisi}
EKE garantisce una doppia autenticazione grazie alla doppia challenge scambiata
tra i due utenti, i quali procedono con l'utilizzo della chiave effimera
solamente se i valori decifrati ricevuti coincidono con quelli generati.
Inoltre siamo protetti da eventuali dictionary attacks, indipendentemente dal
fatto che siano on-line od off-line, in quanto le informazioni che si riescono a
ricavare sono solamente dei numeri computazionalmente difficili da utilizzare
per poter ricavare la chiave effimera.

\end{document}
